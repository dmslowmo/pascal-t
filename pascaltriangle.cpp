/**
This program can generate Pascal Triangle for as many rows as specified by user.
In addition, it is also possible to limit the number size generated by using modulus operand (%).
The usage:
    ./pascalTriangle arg1 arg2
    where arg1 = no. of rows -- (required),
          arg2 = the modulus value -- if '0' or no input, the default is no modulus, maximum number is UINT_MAX
*/

#include <iostream>
#include <sstream>
#include <cstdlib>
#include <climits>
#include <vector>
#include <string>
#include <functional>

using namespace std;

using Row = vector<int>;
using Rows = vector<Row>;
using RowStringGenerator = function<string(string, Row, unsigned)>;

constexpr bool DarkBackground = true;
constexpr unsigned NumOfPossibleColors = 7;

string rowAsMultiColorString(string leadingSpaces, Row row, unsigned modulo = UINT_MAX)
{
	string str = leadingSpaces;
	for (auto element : row) {
		str += "\033[1;" +
				to_string(30 + (element % modulo) % NumOfPossibleColors + static_cast<unsigned>(DarkBackground)) +
				"m"; //the color code prefix
		str += to_string(element % modulo); //the element to print
		str += "\033[0m"; //the suffix to reset the color
		str += " ";
	}
	str.pop_back();
	return str;
}

string rowAsString(string leadingSpaces, Row row, unsigned modulo= UINT_MAX)
{
	string str = leadingSpaces;
	for (auto element : row) {
		str += to_string(element % modulo);
		str += " ";
	}
	str.pop_back();
	return str;
}

Rows pascalTriangle(int level)
{
	if (level == 0) {
		cout << "invalid argument: " << level << endl;
		throw;
	} else if (level == 1) {
		Row row = Row{1};
		return Rows{row};
	} else if (level == 2) {
		Rows triangle = pascalTriangle(1);
		triangle.push_back(Row{1, 1});
		return triangle;
	} else {
		Rows triangleAbove = pascalTriangle(level - 1);
		Row rowAbove = triangleAbove[level - 2];
		Row row = Row{1};
		for (int i = 1; i < (level - 1); ++i) {
			unsigned int element = rowAbove[i - 1] + rowAbove[i];
			row.push_back(element);
		}
		row.push_back(1);
		Rows triangle = triangleAbove;
		triangle.push_back(row);
		return triangle;
	}
}

string serializeTriangle(Rows triangle, RowStringGenerator rowStringGenerator, unsigned modulo = UINT_MAX)
{
	ostringstream os;
	string leadingSpaces = string(triangle.size(), ' ');
	for (Row row : triangle) {
		os << rowStringGenerator(leadingSpaces, row, modulo);
		os << endl;
		leadingSpaces.pop_back();
	}
	return os.str();
}

void usage(const string& arg0)
{
	cout << "Usage: " << arg0 << " [levels]" << " [optional: modulo]" << "[optional: monochrome]" << endl;
	cout << "where levels > 0 and modulo > 0" << endl;
}

int main(int argc, char* argv[])
{
	if (argc < 2) {
		usage(string(argv[0]));
		return 1;
	}
	int levels = atoi(argv[1]);
	unsigned modulo = UINT_MAX;
	if (argc > 2) {
		modulo = atoi(argv[2]);
	}
	if (levels == 0 || modulo == 0) {
		usage(string(argv[0]));
		return 1;
	}

	using namespace placeholders; // for _1, _2, _3...

	Rows triangle = pascalTriangle(levels);
	RowStringGenerator f = bind(rowAsMultiColorString, _1, _2, _3);
	cout << serializeTriangle(triangle, f, modulo) << endl;
	return 0;
}
